# âœ… Pair with Given Sum in a Sorted Array

**Problem Link:** [GFG Problem](https://www.geeksforgeeks.org/problems/pair-with-given-sum-in-a-sorted-array4940/0)

---

### ğŸ“Š Difficulty

`Easy`

### ğŸ·ï¸ Tags

`Two-pointer-algorithm`, `Arrays`, `Data Structures`, `Algorithms`

---

## ğŸ“ Problem Description

Given a **sorted array** `arr[]` and an integer `target`, find the **number of pairs** in `arr[]` whose sum is equal to `target`.

- Pairs should have **distinct indices**.

---

## ğŸ“Œ Examples

**Input:**  
`arr[] = [-1, 1, 5, 5, 7], target = 6`

**Output:**  
`3`

**Explanation:**  
Pairs with sum 6: `{1,5}`, `{1,5}`, `{-1,7}`

**Input:**  
`arr[] = [1, 1, 1, 1], target = 2`

**Output:**  
`6`

**Explanation:**  
All pairs sum to 2: `{1,1}` six combinations.

**Input:**  
`arr[] = [-1, 10, 10, 12, 15], target = 125`

**Output:**  
`0`

**Explanation:**  
No pair sums to 125.

---

## ğŸ”’ Constraints

- \(-10^5 \leq target \leq 10^5\)
- \(2 \leq arr.size() \leq 10^5\)
- \(-10^5 \leq arr[i] \leq 10^5\)

---

## âš¡ Expected Complexities

- **Time Complexity:** O(n)
- **Auxiliary Space Complexity:** O(1)

---

### ğŸš€ My Approach

- Use **two-pointer technique**: `l = 0`, `r = arr.size()-1`.
- Traverse array from both ends.
- If sum is less than target, move `l` forward; if sum is greater, move `r` backward.
- If sum equals target, count all duplicates for both pointers and update answer.
- Handle case when both pointers point to the same number to avoid double counting.

---

## ğŸ’» Code (C++)

```cpp
class Solution {
  public:
    int countPairs(vector<int> &arr, int target) {
        int ans = 0, l = 0, r = arr.size()-1;
        while(l < r){
            int currsum = arr[l] + arr[r];
            if (currsum > target){
                r--;
            }else if(currsum < target){
                l++;
            }else{
                int e1 = arr[l], e2 = arr[r], c1 = 0, c2 = 0;
                while(l <= r && arr[l] == e1){
                    l++;
                    c1++;
                }
                while(l <= r && arr[r] == e2){
                    r--;
                    c2++;
                }
                if(e1 == e2){
                    ans += (c1 * (c1 - 1))/2;
                }else{
                    ans += c1 * c2;
                }
            }
        }
        return ans;
    }
};
```

ğŸ¤ Contribution  
If you liked this solution, feel free to â­ the repo and connect with me on [LinkedIn](https://www.linkedin.com/in/sarvesh-choudhary-7571a6126/).

---

<p align="center"> <b>ğŸ“Visitor Count</b> </p> <p align="center"> <img src="https://visitor-badge.laobi.icu/badge?page_id=sarveshguru.GFG-POTD" /> </p>

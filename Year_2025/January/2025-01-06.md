# âœ… Sum Pair Closest to Target

**Problem Link:** [GFG Problem](https://www.geeksforgeeks.org/problems/pair-in-array-whose-sum-is-closest-to-x1124/0)

---

### ğŸ“Š Difficulty

`Easy`

### ğŸ·ï¸ Tags

`Arrays`, `Data Structures`, `Two-pointer-algorithm`

---

## ğŸ“ Problem Description

Given an array `arr[]` and a number `target`, find a pair of elements `(a, b)` in `arr[]` (where `a â‰¤ b`) whose **sum is closest** to the `target`.

- Return the pair in **sorted order**.
- If multiple pairs have the same closest sum, return the pair with **maximum absolute difference**.
- If no such pair exists, return an empty array.

---

## ğŸ“Œ Examples

**Input:**  
`arr[] = [10, 30, 20, 5], target = 25`

**Output:**  
`[5, 20]`

**Explanation:**  
`5 + 20 = 25` is closest to `25`.

**Input:**  
`arr[] = [5, 2, 7, 1, 4], target = 10`

**Output:**  
`[2, 7]`

**Explanation:**  
Multiple pairs have sum closest to `10`: `(4,5)`, `(2,7)`, `(4,7)`.  
Pair `(2,7)` has the **maximum absolute difference**.

**Input:**  
`arr[] = [10], target = 10`

**Output:**  
`[]`

**Explanation:**  
Only one element, no pair exists.

---

## ğŸ”’ Constraints

- \(1 \leq arr.size() \leq 2 \times 10^5\)
- \(0 \leq target \leq 2 \times 10^5\)
- \(0 \leq arr[i] \leq 10^5\)

---

## âš¡ Expected Complexities

- **Time Complexity:** O(n log n)
- **Auxiliary Space Complexity:** O(1)

---

### ğŸš€ My Approach

- Sort the array.
- Use **two pointers** (`l = 0`, `r = arr.size()-1`) to traverse from both ends.
- Calculate the sum and compare its difference with the target to track the closest pair.
- Update the pair if the current sum is closer or if absolute difference is higher for the same sum.
- Return the resulting pair.

---

## ğŸ’» Code (C++)

```cpp
class Solution {
  public:
    vector<int> sumClosest(vector<int>& arr, int target) {
        if(arr.size() < 2) return {};
        sort(arr.begin(), arr.end());

        vector<int> result(2);
        int l = 0, r = arr.size() - 1;
        result[0] = arr[l];
        result[1] = arr[r];

        while(l < r){
            int currsum = arr[l] + arr[r];
            int currdiff = abs(currsum - target);
            int exdiff = abs(result[0] + result[1] - target);

            if(currdiff < exdiff){
                result[0] = arr[l];
                result[1] = arr[r];
            }

            if(currsum < target){
                l++;
            }else{
                r--;
            }
        }
        return result;
    }
};
```

ğŸ¤ Contribution  
If you liked this solution, feel free to â­ the repo and connect with me on [LinkedIn](https://www.linkedin.com/in/sarvesh-choudhary-7571a6126/).

---

<p align="center"> <b>ğŸ“Visitor Count</b> </p> <p align="center"> <img src="https://visitor-badge.laobi.icu/badge?page_id=sarveshguru.GFG-POTD" /> </p>

# âœ… Inorder Traversal

**Problem Link:** [GFG Problem](https://www.geeksforgeeks.org/problems/inorder-traversal/0)

---

### ğŸ“Š Difficulty

`Easy`

### ğŸ·ï¸ Tags

`Tree`, `Data Structures`

---

## ğŸ“ Problem Description

Given a Binary Tree, your task is to return its **In-Order Traversal**.

An inorder traversal first:

1. Visits the **left child** (including its entire subtree)
2. Visits the **node** itself
3. Finally, visits the **right child** (including its entire subtree)

**Follow Up:** Try solving this with **O(1) auxiliary space**.

---

## ğŸ“Œ Examples

**Input:**  
root[] = [1, 2, 3, 4, 5]  
**Output:**  
[4, 2, 5, 1, 3]  
**Explanation:** The in-order traversal of the given binary tree is [4, 2, 5, 1, 3].

---

**Input:**  
root[] = [8, 1, 5, N, 7, 10, 6, N, 10, 6]  
**Output:**  
[1, 7, 10, 8, 6, 10, 5, 6]  
**Explanation:** The in-order traversal of the given binary tree is [1, 7, 10, 8, 6, 10, 5, 6].

---

## ğŸ”’ Constraints

- \(1 \leq \text{number of nodes} \leq 10^5\)
- \(0 \leq \text{node->data} \leq 10^5\)

---

## âš¡ Expected Complexities

- **Time Complexity:** O(n)
- **Auxiliary Space Complexity:** O(h) (where h = height of tree, due to recursion stack)

---

### ğŸš€ My Approach

- The idea is to use **recursion** for inorder traversal.
- Create a helper function `solve` that:
  1. Recursively traverses the **left subtree**.
  2. Stores the current nodeâ€™s data in the result vector.
  3. Recursively traverses the **right subtree**.
- Finally, return the result vector.

_(Follow-up: For O(1) auxiliary space, Morris Traversal can be used, but recursion/stack-based solutions are acceptable here.)_

---

## ğŸ’» Code (C++)

```cpp
/*
// Tree Node
class Node {
public:
    int data;
    Node* left;
    Node* right;

    // Constructor to initialize a new node
    Node(int val) {
        data = val;
        left = NULL;
        right = NULL;
    }
};
*/

class Solution {
public:
    // Function to return a list containing the inorder traversal of the tree.
    vector<int> inOrder(Node* root) {
        vector<int> res;
        solve(root, res);
        return res;
    }

    void solve(Node* node, vector<int> &res) {
        if (!node) return;
        solve(node->left, res);
        res.push_back(node->data);
        solve(node->right, res);
    }
};
```

ğŸ¤ Contribution and Support
Connect with me on ğŸš€

- Sarvesh Choudhary

---

<p align="center"> <b>ğŸ“Visitor Count</b> </p> <p align="center"> <img src="https://visitor-badge.laobi.icu/badge?page_id=sarveshguru.GFG-POTD" /> </p>

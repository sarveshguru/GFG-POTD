# 🌳 Lowest Common Ancestor in a BST

**Problem Link**: [Lowest Common Ancestor in a BST - GFG](https://www.geeksforgeeks.org/problems/lowest-common-ancestor-in-a-bst/0)

---

### 📊 Difficulty

`Easy`

### 🏷️ Tags

`Binary Search Tree`, `Tree`, `Data Structures`

---

## 📌 Problem Statement

Given a Binary Search Tree (with all values unique) and two nodes `n1` and `n2` (`n1 != n2`). You may assume that both nodes exist in the tree. Find the **Lowest Common Ancestor (LCA)** of the given two nodes in the BST.

LCA between two nodes `n1` and `n2` is defined as the lowest node that has both `n1` and `n2` as descendants (where we allow a node to be a descendant of itself).

---

## ✨ Examples

**Input:**  
`root = [5, 4, 6, 3, N, N, 7, N, N, N, 8], n1 = 7, n2 = 8`  
**Output:**  
`7`  
**Explanation:**  
`7` is the closest node to both `7` and `8`, which is also an ancestor of both the nodes.

**Input:**  
`root = [20, 8, 22, 4, 12, N, N, N, N, 10, 14], n1 = 8, n2 = 14`  
**Output:**  
`8`  
**Explanation:**  
`8` is the closest node to both `8` and `14`, which is also an ancestor of both the nodes.

**Input:**  
`root = [2, 1, 3], n1 = 1, n2 = 3`  
**Output:**  
`2`  
**Explanation:**  
`2` is the closest node to both `1` and `3`, which is also an ancestor of both the nodes.

---

## 🎯 Constraints

- `1 <= number of nodes <= 10^5`
- `1 <= node->data <= 10^5`
- `1 <= n1, n2 <= 10^5`

---

## ⏱️ Expected Complexities

- **Time Complexity**: `O(h)`
- **Auxiliary Space**: `O(1)`

---

## 🧠 My Approach

1. Use BST property:
   - If both `n1` and `n2` are **greater** than `root->data`, move to `root->right`.
   - If both are **smaller**, move to `root->left`.
2. The first node where they diverge (or equal to one of them) is the **LCA**.
3. Implement recursively as per BST traversal rules.

---

## 🖥️ Code Implementation

```cpp
/* // Tree Node
class Node {
public:
    int data;
    Node* left;
    Node* right;
    // Constructor to initialize a new node
    Node(int val) {
        data = val;
        left = NULL;
        right = NULL;
    }
};
*/
class Solution {
public:
    Node* LCA(Node* root, Node* n1, Node* n2) {
        // code here
        if(!root) return NULL;
        if(n1->data > root->data && n2->data > root->data) return LCA(root->right, n1, n2);
        if(n1->data < root->data && n2->data < root->data) return LCA(root->left, n1, n2);
        return root;
    }
};
```

🤝 Contribution
If you liked this solution, feel free to ⭐ the repo and connect with me on [LinkedIn](https://www.linkedin.com/in/sarvesh-choudhary-7571a6126/).

---

<p align="center"> <b>👀 Visitor Count</b> </p> <p align="center"> <img src="https://visitor-badge.laobi.icu/badge?page_id=sarveshguru.GFG-POTD" /> </p>

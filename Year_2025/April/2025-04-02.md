# 🌳 BFS of Graph

**Problem Link**: [BFS Traversal of Graph - GFG](https://www.geeksforgeeks.org/problems/bfs-traversal-of-graph/0)

---

### 📊 Difficulty

`Easy`

### 🏷️ Tags

`Graph`, `BFS`, `Data Structures`, `Algorithms`

---

## 📌 Problem Statement

Given a connected undirected graph containing `V` vertices, represented by a 2-D adjacency list `adj[][]`, where each `adj[i]` represents the list of vertices connected to vertex `i`.

Perform a **Breadth First Search (BFS)** traversal starting from vertex `0`, visiting vertices from left to right according to the given adjacency list, and return a list containing the BFS traversal of the graph.

**Note:** Traverse in the **same order** as they appear in the given adjacency list.

---

## ✨ Examples

**Input:**  
`adj[][] = [[2, 3, 1], [0], [0, 4], [0], [2]]`  
**Output:**  
`[0, 2, 3, 1, 4]`  
**Explanation:**  
Starting from `0`, the BFS traversal follows:

- Visit `0` → Output: `0`
- Visit `2` → Output: `0, 2`
- Visit `3` → Output: `0, 2, 3`
- Visit `1` → Output: `0, 2, 3, 1`
- Visit `4` → Final Output: `0, 2, 3, 1, 4`

**Input:**  
`adj[][] = [[1, 2], [0, 2], [0, 1, 3, 4], [2], [2]]`  
**Output:**  
`[0, 1, 2, 3, 4]`  
**Explanation:**  
Starting from `0`, BFS traversal:

- Visit `0` → `0`
- Visit `1` → `0, 1`
- Visit `2` → `0, 1, 2`
- Visit `3` → `0, 1, 2, 3`
- Visit `4` → Final Output: `0, 1, 2, 3, 4`

---

## 🎯 Constraints

- `1 ≤ V = adj.size() ≤ 10^4`
- `1 ≤ adj[i][j] ≤ 10^4`

---

## ⏱️ Expected Complexities

- **Time Complexity**: `O(V + E)`
- **Auxiliary Space**: `O(V + E)`

---

## 🧠 My Approach

1. Perform **Breadth First Search (BFS)** using a queue.
2. Maintain a **visited array** to avoid revisiting nodes.
3. Start from vertex `0`, mark it visited, and push it to the queue.
4. While the queue is not empty:
   - Pop the front node and append it to the result.
   - Traverse its adjacency list and push unvisited neighbors to the queue, marking them visited.
5. This guarantees BFS traversal **from left to right** according to adjacency list order.

---

## 🖥️ Code Implementation

```cpp
class Solution {
public:
    // Function to return Breadth First Traversal of given graph.
    vector<int> bfs(vector<vector<int>> &adj) {
        // Code here
        int n = adj.size();
        vector<int> res, vis(n, 0);
        queue<int> q;
        q.push(0);
        vis[0] = 1;
        while(!q.empty()){
            int node = q.front();
            q.pop();
            res.push_back(node);
            for(auto it : adj[node]){
                if(!vis[it]){
                    q.push(it);
                    vis[it] = 1;
                }
            }
        }
        return res;
    }
};
```

🤝 Contribution
If you liked this solution, feel free to ⭐ the repo and connect with me on [LinkedIn](https://www.linkedin.com/in/sarvesh-choudhary-7571a6126/).

---

<p align="center"> <b>👀 Visitor Count</b> </p> <p align="center"> <img src="https://visitor-badge.laobi.icu/badge?page_id=sarveshguru.GFG-POTD" /> </p>

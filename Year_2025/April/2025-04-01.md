# ✅ DFS of Graph

**Problem Link:** [GFG Problem](https://www.geeksforgeeks.org/problems/depth-first-traversal-for-a-graph/0)

---

### 📊 Difficulty

`Easy`

### 🏷️ Tags

`Graph`, `DFS`, `Data Structures`, `Algorithms`

---

## 📝 Problem Description

Given a connected **undirected graph** containing `V` vertices represented by a 2D adjacency list `adj[][]`,  
where each `adj[i]` represents the list of vertices connected to vertex `i`.

Perform a **Depth First Search (DFS)** traversal starting from vertex `0`, visiting vertices from **left to right** as per the given adjacency list, and return a list containing the DFS traversal of the graph.

**Note:** Do traverse in the same order as they appear in the given adjacency list.

---

## 📌 Examples

**Input:**  
`adj[][] = [[2, 3, 1], [0], [0, 4], [0], [2]]`

**Output:**  
`[0, 2, 4, 3, 1]`

**Explanation:**

- Starting from `0`: Output = `[0]`
- Visit `2`: Output = `[0, 2]`
- Visit `4`: Output = `[0, 2, 4]`
- Backtrack to `2`, then `0`, visit `3`: Output = `[0, 2, 4, 3]`
- Backtrack to `0`, visit `1`: Final Output = `[0, 2, 4, 3, 1]`

---

**Input:**  
`adj[][] = [[1, 2], [0, 2], [0, 1, 3, 4], [2], [2]]`

**Output:**  
`[0, 1, 2, 3, 4]`

**Explanation:**

- Starting from `0`: Output = `[0]`
- Visit `1`: Output = `[0, 1]`
- Visit `2`: Output = `[0, 1, 2]`
- Visit `3`: Output = `[0, 1, 2, 3]`
- Backtrack to `2`, then visit `4`: Final Output = `[0, 1, 2, 3, 4]`

---

## 🔒 Constraints

- \(1 \leq V = adj.size() \leq 10^4\)
- \(1 \leq adj[i][j] \leq 10^4\)

---

## ⚡ Expected Complexities

- **Time Complexity:** O(V + E)
- **Auxiliary Space Complexity:** O(V) (for visited + recursion stack)

---

### 🚀 My Approach

- I used **recursion** for DFS traversal.
- Maintain a `visited` array to avoid revisiting nodes.
- Start from node `0` and:
  - Mark the current node as visited.
  - Push it into the result list.
  - Recursively call DFS for all neighbors in the same order as adjacency list.
- If graph is disconnected, ensure all vertices are covered (but here graph is connected).

---

## 💻 Code (C++)

```cpp
class Solution {
public:
    int n;
    vector<bool> vis;
    vector<int> ans;

    vector<int> dfsOfGraph(vector<vector<int>>& adj) {
        n = adj.size();
        vis.resize(n, false);

        // Start DFS from node 0
        dfs(0, adj);
        return ans;
    }

private:
    void dfs(int node, vector<vector<int>>& adj) {
        vis[node] = true;
        ans.push_back(node);

        for (auto &ngbr : adj[node]) {
            if (!vis[ngbr]) {
                dfs(ngbr, adj);
            }
        }
    }
};
```

🤝 Contribution and Support
Connect with me on
🚀 - Sarvesh Choudhary

---

<p align="center"> <b>📍Visitor Count</b> </p> <p align="center"> <img src="https://visitor-badge.laobi.icu/badge?page_id=sarveshguru.GFG-POTD" /> </p>

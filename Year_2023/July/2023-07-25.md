# üå≥ Level Order in Spiral Form

**Problem Link**: [Level Order in Spiral Form - GFG](https://www.geeksforgeeks.org/problems/level-order-traversal-in-spiral-form/0)

---

### üìä Difficulty

`Easy`

### üè∑Ô∏è Tags

`Recursion`, `Stack`, `TreeData`, `Structures`, `Algorithms`

---

## üìå Problem Statement

Given a root binary tree, the task is to find the **spiral order traversal** of the tree and return a list containing the elements.

- **Spiral Order Traversal** means:
  - Starting from level `0` (root node),
  - For all **even levels**, print node values from **right to left**.
  - For all **odd levels**, print node values from **left to right**.

---

## ‚ú® Examples

**Input:**  
`root = [1, 3, 2]`  
**Output:**  
`[1, 3, 2]`  
**Explanation:**  
Start with root (`1`), print level 0 (right to left), then level 1 (left to right).

**Input:**  
`root = [10, 20, 30, 40, 60]`  
**Output:**  
`[10, 20, 30, 60, 40]`  
**Explanation:**  
Start with root (`10`), print level 0 (right to left), level 1 (left to right), and continue alternating.

---

## üéØ Constraints

- `1 ‚â§ number of nodes ‚â§ 10^5`
- `0 ‚â§ node->data ‚â§ 10^5`

---

## ‚è±Ô∏è Expected Complexities

- **Time Complexity**: `O(n)`
- **Auxiliary Space**: `O(n)` (for queue and temporary level vector)

---

## üß† My Approach

1. We perform a **level order traversal** using a queue.
2. For each level:
   - Store the nodes in a temporary vector.
   - If the current level is **even**, reverse the vector (to satisfy right-to-left order).
   - Append the vector elements to the final answer.
3. Toggle the direction flag after each level to alternate between right-to-left and left-to-right.
4. This ensures that nodes are visited in **spiral order** without modifying the tree.

---

## üñ•Ô∏è Code Implementation

```cpp
/* A binary tree node has data, pointer to left child and a pointer to right child
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
    Node(int x){
        data = x;
        left = right = NULL;
    }
}; */

//Function to return a list containing the level order traversal in spiral form.
vector<int> findSpiral(Node *root) {
    //Your code here
    vector <int> ans;
    queue<Node*> q;
    q.push(root);
    bool b = true;
    while(q.size()){
        int s=q.size();
        vector<int> level;
        for(int i=0; i<s; i++){
            Node *temp = q.front();
            q.pop();
            level.push_back(temp->data);
            if(temp->left) q.push(temp->left);
            if(temp->right) q.push(temp->right);
        }
        if(b==true) reverse(level.begin(),level.end());
        for(auto x:level) ans.push_back(x);
        b=!b;
    }
    return ans;
}
```

ü§ù Contribution
If you liked this solution, feel free to ‚≠ê the repo and connect with me on [LinkedIn](https://www.linkedin.com/in/sarvesh-choudhary-7571a6126/).

---

<p align="center"> <b>üëÄ Visitor Count</b> </p> <p align="center"> <img src="https://visitor-badge.laobi.icu/badge?page_id=sarveshguru.GFG-POTD" /> </p>

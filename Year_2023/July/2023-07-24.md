# üå≥ Right View of Binary Tree

**Problem Link**: [Right View of Binary Tree - GFG](https://www.geeksforgeeks.org/problems/right-view-of-binary-tree/0)

---

### üìä Difficulty

`Easy`

### üè∑Ô∏è Tags

`TreeData`, `Structures`

---

## üìå Problem Statement

Given the root of a binary tree, your task is to return the values visible from the **Right View** of it.  
The Right View of a Binary Tree is the set of nodes visible when the tree is viewed from the **right side**.

---

## ‚ú® Examples

**Input:**  
`root = [1, 2, 3, 4, 5]`  
**Output:**  
`[1, 3, 5]`

**Input:**  
`root = [1, 2, 3, 4, N, N, 5]`  
**Output:**  
`[1, 3, 4, 5]`

---

## üéØ Constraints

- `1 ‚â§ number of nodes ‚â§ 10^5`
- `0 ‚â§ node->data ‚â§ 10^5`

---

## ‚è±Ô∏è Expected Complexities

- **Time Complexity**: `O(n)`
- **Auxiliary Space**: `O(h)` (recursive stack, where h = height of tree)

---

## üß† My Approach

1. We need the first node at every depth when viewed from the **right side**.
2. Use **pre-order traversal** (Root ‚Üí Right ‚Üí Left).
3. Keep track of the current depth and the maximum depth already visited.
4. When visiting a node at a new depth for the first time, add it to the result.
5. Recurse right first, then left, to ensure right view is prioritized.

---

## üñ•Ô∏è Code Implementation

```cpp
/* A binary tree node has data, pointer to left child and a pointer to right child
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
    Node(int x){
        data = x;
        left = right = NULL;
    }
}; */

// Should return right view of tree
class Solution {
public:
    // Function to return list containing elements of right view of binary tree.
    void help(Node* root, int cur, int &taken, vector<int> &ans){
        if(!root) return;
        if(taken < cur){
            ans.push_back(root->data);
            taken++;
        }
        cur++;
        help(root->right, cur, taken, ans);
        help(root->left, cur, taken, ans);
    }

    vector<int> rightView(Node *root) {
        vector<int> ans;
        int cur = 1, taken = 0;
        help(root, cur, taken, ans);
        return ans;
    }
};
```

ü§ù Contribution
If you liked this solution, feel free to ‚≠ê the repo and connect with me on [LinkedIn](https://www.linkedin.com/in/sarvesh-choudhary-7571a6126/).

---

<p align="center"> <b>üëÄVisitor Count</b> </p> <p align="center"> <img src="https://visitor-badge.laobi.icu/badge?page_id=sarveshguru.GFG-POTD" /> </p>

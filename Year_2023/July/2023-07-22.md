ğŸ”¹ Remove Duplicates from an Unsorted Linked List  

**Problem Link:** [GFG Problem](https://www.geeksforgeeks.org/problems/remove-duplicates-from-an-unsorted-linked-list/0)  

---

### ğŸ“Š Difficulty  
`Easy`  

### ğŸ·ï¸ Tags  
`Linked List`, `Data Structures`  

---

## ğŸ“ Problem Description  

Given an unsorted linked list. The task is to remove duplicate elements from this unsorted Linked List.  
When a value appears in multiple nodes, the node which appeared first should be kept, all other duplicates are to be removed.  

---

## ğŸ“Œ Examples  

**Input:**  
LinkedList: 5 â†’ 2 â†’ 2 â†’ 4  

**Output:**  
5 â†’ 2 â†’ 4  

**Explanation:**  
2 is repeated, so extra occurrences are removed.  

---

**Input:**  
LinkedList: 2 â†’ 2 â†’ 2 â†’ 2 â†’ 2  

**Output:**  
2  

**Explanation:**  
All duplicates of 2 are removed, only one remains.  

---

## ğŸ”’ Constraints  

- \(1 \leq \text{number of nodes} \leq 10^6\)  
- \(0 \leq \text{node->data} \leq 10^6\)  

---

## âš¡ Expected Complexities  

- **Time Complexity:** O(n)  
- **Auxiliary Space Complexity:** O(n)  

---

### My Approach  
- I used two pointers: **prev** and **next** to reverse the links of each node.  
- Initially, `prev` is set to `NULL`, and `head` points to the first node.  
- In each iteration:  
  - Store the next node in `next`.  
  - Update the current nodeâ€™s next pointer to point to `prev`.  
  - Move `prev` to the current node.  
  - Move `head` to `next`.  
- At the end, `prev` will be the new head of the reversed linked list.  

---

## ğŸ’» Code (C++)  

```cpp
/* The structure of linked list is the following
struct Node {
 int data;
 struct Node *next;
 Node(int x) {
 data = x;
 next = NULL;
 }
};
*/

class Solution {
public:
 //Function to remove duplicates from unsorted linked list.
 Node * removeDuplicates( Node *head) {
 // your code goes here
 unordered_set<int>st;
 if(head == NULL || head->next == NULL)
     return head;
 st.insert(head->data);
 Node* prev = head;
 Node* temp = head->next;
 while(temp!=NULL){
     int x=temp->data;
     if(st.find(x)!=st.end()){
         prev->next=temp->next;
         temp=temp->next;
     }
     else{
         st.insert(x);
         prev=temp;
     }
 }
 return head;
 }
};
```

ğŸ¤ Contribution and Support
Connect with me on
ğŸš€ - Sarvesh Choudhary

---

<p align="center"> <b>ğŸ“Visitor Count</b> </p> <p align="center"> <img src="https://visitor-badge.laobi.icu/badge?page_id=sarveshguru.GFG-POTD" /> </p>

# ğŸŒ³ Remove Duplicates from an array

**Problem Link**: [Remove Duplicates from an array - GFG](https://www.geeksforgeeks.org/problems/remove-duplicates-in-small-prime-array/0)

---

### ğŸ“Š Difficulty

`Easy`

### ğŸ·ï¸ Tags

`Arrays`, `Hash`, `Prime Number`, `Data Structures`

---

## ğŸ“Œ Problem Statement

Given an array `arr[]` consisting of positive integers, return the array by removing all duplicate numbers.

---

## âœ¨ Examples

**Input:**  
`arr[] = [2, 2, 3, 3, 7, 5]`  
**Output:**  
`[2, 3, 7, 5]`  
**Explanation:**  
After removing the duplicates `2` and `3` we get `2 3 7 5`.

**Input:**  
`arr[] = [1, 2, 3, 4, 5]`  
**Output:**  
`[1, 2, 3, 4, 5]`  
**Explanation:**  
There doesn't exists any duplicate element.

---

## ğŸ¯ Constraints

- `1 â‰¤ arr.size() â‰¤ 10^6`
- `2 â‰¤ arr[i] â‰¤ 10^9`

---

## â±ï¸ Expected Complexities

- **Time Complexity**: `O(n)`
- **Auxiliary Space**: `O(1)`

---

## ğŸ§  My Approach

1. Traverse the array and track frequencies using a hash map.
2. For each element, if its count becomes `1`, append it to the result list to preserve order.
3. Return the result vector.

---

## ğŸ–¥ï¸ Code Implementation

```cpp
class Solution {
  public:
    vector<int> removeDuplicate(vector<int>& arr) {
        // code here
        unordered_map<int, int>m;
        vector<int>ans;
        for(int i = 0; i < arr.size(); i++){
            m[arr[i]]++;
            if(m[arr[i]]==1) ans.push_back(arr[i]);
        }
        return ans;
    }
};
```

ğŸ¤ Contribution
If you liked this solution, feel free to â­ the repo and connect with me on [LinkedIn](https://www.linkedin.com/in/sarvesh-choudhary-7571a6126/).

---

<p align="center"> <b>ğŸ‘€ Visitor Count</b> </p> <p align="center"> <img src="https://visitor-badge.laobi.icu/badge?page_id=sarveshguru.GFG-POTD" /> </p>
